---
layout: post
categories:
  - algorithm
title: Meet In The Middle
date: 2024-04-10 18:35:00 +09:00
tags:
  - search
---
>중간에서 만나기.\
>만일 브루트 포스를 써야할 때가 있는데, 데이터의 크기가 너무 클 경우 사용할 수 있다!

---

- 특정 조합의 개수를 찾는 등 브루트 포스 알고리즘을 써야하는 경우가 있다.
- 하지만, 원소의 개수가 너무 많아지면 시간 복잡도가 너무 커질 수 있다!
	- 크기 N의 경우 O($2^N$)만큼 걸리는데, N이 커짐에 따라 기하급수적으로 시간이 늘어난다.
- 이런 경우, 집합을 두 개로 나눠 모든 경우의 수를 구한 다음 이진 탐색을 이용해 조합을 찾을 수 있다.

---

# 시간 복잡도

- O($log(2^N)*2^N$) ≈ O($N*2^N$)

---

# 과정

- 크기 N의 배열 arr이 있고, 배열의 원소를 더해 MAX값 이하가 되는 경우의 수를 구한다.
	- `arr = {4, 1, 3, 2}`이고, `MAX = 4`라고 하자.
- arr을 절반으로 나눠 만들 수 있는 모든 경우의 수를 arr_left, arr_right에 나눠 담는다.
	- 두 배열 모두 0번째 원소는 0이다!
	- `arr_left = {0, 4, 1, 5}, arr_right = {0, 3, 2, 5}`
- `arr_right`를 오름차순으로 정렬한다.
	- `arr_left = {0, 4, 1, 5}, arr_right = {0, 2, 3, 5}`
- `val = MAX - arr_left[i], i = 0 to len(arr_left)`와 `arr_right`의 원소값과 비교한다.
	- `arr_right[j] <= val, 0 <= j < len(arr_right)`를 만족하는 가장 큰 `j`를 찾는다!
	- `j`는 이진 탐색을 이용해 찾는다.
- 모든 `i`에 대해 찾은 `j + 1`의 값을 모두 더한 것이 조건을 만족하는 모든 경우의 수가 된다!
	- `i = 0, j = 2`
	- `i = 1, j = 0`
	- `i = 2, j = 2`
	- `i = 3, j = 2`