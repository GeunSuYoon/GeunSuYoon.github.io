<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-22T20:43:08+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">지식쌓기</title><subtitle>조금씩, 천천히</subtitle><entry><title type="html">01. 컴퓨터 시스템 개요</title><link href="http://localhost:4000/cs/os/outlineofcs.html" rel="alternate" type="text/html" title="01. 컴퓨터 시스템 개요" /><published>2024-02-22T19:06:00+09:00</published><updated>2024-02-22T19:06:00+09:00</updated><id>http://localhost:4000/cs/os/outlineofcs</id><content type="html" xml:base="http://localhost:4000/cs/os/outlineofcs.html"><![CDATA[<h1 id="goal">Goal</h1>]]></content><author><name></name></author><category term="cs" /><category term="os" /><summary type="html"><![CDATA[Goal]]></summary></entry><entry><title type="html">이항 계수 3</title><link href="http://localhost:4000/boj/binomialcoefficient3.html" rel="alternate" type="text/html" title="이항 계수 3" /><published>2024-02-22T16:23:00+09:00</published><updated>2024-02-22T16:23:00+09:00</updated><id>http://localhost:4000/boj/binomialcoefficient3</id><content type="html" xml:base="http://localhost:4000/boj/binomialcoefficient3.html"><![CDATA[<blockquote>
  <p><a href="">백준 11401. 이항 계수3</a>의 풀이이다.</p>
</blockquote>

<hr />

<h1 id="페르마의-소정리">페르마의 소정리</h1>
<ul>
  <li>p가 소수이면, 모든 정수 a에 대해 a<sup>p</sup> ≅ a (mod p)</li>
  <li>p가 소수이고 a가 p의 배수가 아니면 a<sup>p-1</sup> ≅ 1 (mod p)</li>
</ul>

<hr />

<h1 id="응용">응용</h1>
<ul>
  <li>정수 a, b, p에 대해 (p는 소수) 이하의 식으로 정리할 수 있다.</li>
  <li>b<sup>p-1</sup> = b*b<sup>p-2</sup> ≅ 1 (mod p)</li>
  <li>b<sup>p-2</sup> ≅ b<sup>-1</sup> (mod p)</li>
  <li>a\ * b<sup>-1</sup> % p ≅ a\ * b<sup>p-2</sup>  % p (mod % p)</li>
</ul>

<hr />

<h1 id="풀이">풀이</h1>
<ul>
  <li>p는 1,000,000,007로 주어졌다.</li>
  <li><sub>n</sub>C<sub>k</sub> 는 a / b = a * b<sup>-1</sup>로 표현할 수 있다. (a = n! / (n - k)!, b = k!)</li>
  <li>a * b<sup>-1</sup> % p = a * b<sup>p-2</sup> / b<sup>p-1</sup> % p≅ a * b<sup>p-2</sup>  % p (mod p)</li>
  <li>a % p와 b<sup>p-2</sup>  % p를 따로 구해준 뒤 곱한 결과에 % p를 취한다.</li>
</ul>]]></content><author><name></name></author><category term="boj" /><category term="math" /><summary type="html"><![CDATA[백준 11401. 이항 계수3의 풀이이다.]]></summary></entry><entry><title type="html">Greedy</title><link href="http://localhost:4000/algorithm/greedy.html" rel="alternate" type="text/html" title="Greedy" /><published>2024-02-22T13:31:00+09:00</published><updated>2024-02-22T13:31:00+09:00</updated><id>http://localhost:4000/algorithm/greedy</id><content type="html" xml:base="http://localhost:4000/algorithm/greedy.html"><![CDATA[<blockquote>
  <p>매 선택에서 지금 이 순간 당장 최적인 답을 선택해 적합한 결과를 도출하는 알고리즘이다.</p>

  <p>특정 조건에서만 사용이 가능하다.</p>

  <p>해당 조건을 만족하는 문제를 매트로이드 문제라고 한다.</p>
</blockquote>

<hr />

<h1 id="개요">개요</h1>
<ul>
  <li><a href="#설명">설명</a></li>
  <li><a href="#조건">조건</a></li>
  <li><a href="#특징">특징</a></li>
  <li><a href="#단계">단계</a></li>
</ul>

<hr />

<h1 id="설명">설명</h1>
<ul>
  <li>매 선택을 지역적으로 최선인 것을 선택해 최적의 답을 찾아가는 알고리즘.</li>
  <li>지역적으로 최선의 답이 전역적으로 최선이 아닐 수 있다.</li>
  <li>따라서, 이하 두 조건을 만족해야 사용할 수 있다.
    <ul>
      <li>Greedy Choice Property(탐욕스러운 선택 조건)</li>
      <li>Optimal Substructure(최적 부분 구조 조건)</li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="조건">조건</h1>
<h2 id="greedy-choice-property">Greedy Choice Property</h2>
<ul>
  <li>각 단계에서 <font color="#548dd4">최선의 선택</font>을 했을 때 전체 문제에 대한 최적해를 구할 수 있는 경우.</li>
  <li>즉, 지금의 선택이 이후의 선택에 영향을 주어선 안된다.
    <h2 id="optiaml-substructure">Optiaml Substructure</h2>
  </li>
  <li>전체 문제의 최적해가 <font color="#548dd4">부분 문제의 최적해</font>로 구성될 수 있는 경우.</li>
  <li>즉, 전체 문제를 부분 문제로 나누어 최적해를 구한 다음 이를 조합했을 때 전체 문제의 최적해가 돼야 한다.</li>
</ul>

<hr />

<h1 id="특징">특징</h1>
<ul>
  <li>전체 상황에서 최적의 결과를 보장하지 못한다.</li>
  <li>빠르다!</li>
  <li>최적의 답안은 아니지만 최적에 근사한 답안을 제시하므로 근사 알고리즘에 속한다.</li>
</ul>

<hr />

<h1 id="단계">단계</h1>
<ol>
  <li>문제의 최적해 구조 결정</li>
  <li>문제 구조에 맞게 선택 절차 정의 (Selection Procedure, 선택 절차)</li>
  <li>선택 절차에 맞게 선택 수행</li>
  <li>선택된 해가 문제 조건을 만족하는지 검사 (Feasiblitiy Check, 적절성 검사)</li>
  <li>조건을 만족하지 않으면 해당 해 제외</li>
  <li>모든 선택이 완료되면 해답을 검사 (Solution Check, 해답 검사)</li>
  <li>조건을 만족하지 않으면 다시 검사</li>
</ol>

<h2 id="selection-procedure">Selection Procedure</h2>
<ul>
  <li>
    <font color="#548dd4">현재 상태</font>
    <p>에서 <font color="#548dd4">최적인 선택</font>을 한다. 이 선택은 바뀌지 않는다.</p>
  </li>
</ul>

<h2 id="feasibility-check">Feasibility Check</h2>
<ul>
  <li>선택한 것이 <font color="#548dd4">문제의 조건</font>을 만족하는지 확인한다.
    <ul>
      <li>만족하지 않으면 <font color="#ff0000">제외</font>한다.</li>
    </ul>
  </li>
</ul>

<h2 id="solution-check">Solution Check</h2>
<ul>
  <li>모든 선택이 완료되면 최종 선택이 <font color="#548dd4">문제의 조건</font>을 만족하는지 확인한다.
    <ul>
      <li>조건을 만족하면 해답으로 인정한다.</li>
    </ul>
  </li>
</ul>

<hr />]]></content><author><name></name></author><category term="algorithm" /><category term="search" /><category term="approximation" /><summary type="html"><![CDATA[매 선택에서 지금 이 순간 당장 최적인 답을 선택해 적합한 결과를 도출하는 알고리즘이다. 특정 조건에서만 사용이 가능하다. 해당 조건을 만족하는 문제를 매트로이드 문제라고 한다.]]></summary></entry><entry><title type="html">나머지 합</title><link href="http://localhost:4000/boj/remainsum.html" rel="alternate" type="text/html" title="나머지 합" /><published>2024-02-21T20:16:00+09:00</published><updated>2024-02-21T20:16:00+09:00</updated><id>http://localhost:4000/boj/remainsum</id><content type="html" xml:base="http://localhost:4000/boj/remainsum.html"><![CDATA[<blockquote>
  <p><a href="https://www.acmicpc.net/problem/10986">백준 10986. 나머지 합</a>의 풀이이다.</p>
</blockquote>

<p><img src="remainsum_subject.png" alt="remainsum_subject" /></p>

<ul>
  <li>길이 n의 배열에서 부분합이 m으로 나누어 떨어지는 개수를 출력하는 문제.</li>
</ul>

<h3 id="문제-풀이">문제 풀이</h3>
<ul>
  <li>입력이 예제와 같이 들어온다고 하자(n = 5, m = 3).
    <blockquote>
      <p><code class="highlighter-rouge">5 3</code></p>

      <p><code class="highlighter-rouge">1 2 3 1 2</code></p>
    </blockquote>
  </li>
  <li>배열을 A, 누적합을 S, S[i]를 m으로 나눈 나머지를 M으로 표현하면 아래 표와 같이 나온다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>index</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">A[i]</code></td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">S[i]</code></td>
      <td>1</td>
      <td>3</td>
      <td>6</td>
      <td>7</td>
      <td>9</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">M[i]</code></td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>이를 이용해 우린 M이란 배열의 값을 세는 mod란 배열을 만들면 아래와 같이 나온다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>index</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">mod[i]</code></td>
      <td>3</td>
      <td>2</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>이 표에서 같은 index, 즉 동일한 나머지를 갖는 두 구간을 선택해 누적 합을 뺀다면 나머지는 0이 될 것이다.
    <ul>
      <li>나머지가 i인 구간을 2개 뽑는 경우의 수는 mod[i] * (mod[i] - 1) / 2 이다. (<a href="2024-02-21-permuncomb.md">조합</a>)</li>
      <li>물론 mod[i]의 값이 0인 경우엔 세지 않는다.
        <ul>
          <li>i = 0, 3 * 2 / 2 = 3</li>
          <li>i = 1, 2 * 1 / 2 = 1</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>또한, 원래부터 나머지가 0인 구간을 세어주면 누적 합을 m으로 나눈 나머지가 0이 되는 구간을 모두 찾을 수 있다.
    <ul>
      <li>mod[0] = 3.</li>
      <li>3 + 3 + 1 = 7</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="boj" /><category term="math" /><summary type="html"><![CDATA[백준 10986. 나머지 합의 풀이이다.]]></summary></entry><entry><title type="html">Two Pointer</title><link href="http://localhost:4000/technique/twoptr.html" rel="alternate" type="text/html" title="Two Pointer" /><published>2024-02-21T19:21:00+09:00</published><updated>2024-02-21T19:21:00+09:00</updated><id>http://localhost:4000/technique/twoptr</id><content type="html" xml:base="http://localhost:4000/technique/twoptr.html"><![CDATA[<h1 id="two-pointer">Two Pointer</h1>

<ul>
  <li>Sliding Window라고도 불린다.</li>
  <li>완전 탐색으로 해결하려면 시간 초과가 날 수도 있는데, 그 대안으로 쓰이기도 한다.</li>
  <li>
    <p>1차원 배열에서 각자 다른 원소를 가리키는 두 개의 포인터를 조작해 원하는 것을 얻는 형태.</p>
  </li>
  <li>구간 합 및 백준 # 18870(좌표 압축)에서 내가 사용한 중복 원소 제거 등에서 시간 복잡도를 O(n)으로 모든 배열의 원소를 훑어볼 수 있다.</li>
</ul>

<h3 id="구현-내용중복-원소-제거">구현 내용(중복 원소 제거)</h3>
<ul>
  <li>배열이 정렬되어있다 가정하자.</li>
  <li>arr_ptr = 0;</li>
  <li>for arr_cnt = 1 to arr_len - 1
    <ul>
      <li>arr[arr_ptr] != arr[arr_cnt]
        <ul>
          <li>arr[++arr_ptr] = arr[arr_cnt]</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이후 arr_ptr을 arr_len으로 참고할 수 있다!</li>
</ul>

<h3 id="구현-내용수들의-합-백준-2003">구현 내용(수들의 합, 백준 2003)</h3>
<ul>
  <li>n = arr_len, m = target</li>
  <li>front_ptr = 0, sum = 0, m_case = 0</li>
  <li>for rear_ptr = 0 to n - 1
    <ul>
      <li>sum += arr[rear_ptr]</li>
      <li>m &lt; sum ?
        <ul>
          <li>while m &lt; sum
            <ul>
              <li>sum -= arr[front_ptr++]</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>m == sum ? m_case++</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="technique" /><summary type="html"><![CDATA[Two Pointer]]></summary></entry><entry><title type="html">Radix Sort</title><link href="http://localhost:4000/algorithm/radixsort.html" rel="alternate" type="text/html" title="Radix Sort" /><published>2024-02-21T19:19:00+09:00</published><updated>2024-02-21T19:19:00+09:00</updated><id>http://localhost:4000/algorithm/radixsort</id><content type="html" xml:base="http://localhost:4000/algorithm/radixsort.html"><![CDATA[<h1 id="radix-sort">Radix Sort</h1>
<blockquote>
  <p>Comparison Sort의 문제 해결.</p>
</blockquote>

<h3 id="radix-sort-1">Radix Sort</h3>
<ul>
  <li>데이터를 구성하는 기본 요소(Radix)를 이용하여 정렬.</li>
  <li>입력 데이터의 최댓값에 따라 Counting Sort 대신 사용 가능.
    <ul>
      <li>자릿수 기준이므로 나올 수 있는 최대 사이즈는 9(0~9).
        <h4 id="시간복잡도">시간복잡도</h4>
      </li>
    </ul>
  </li>
  <li>O(d * (n + b)) &gt; d는 자릿수, b는 10.</li>
</ul>

<h3 id="장단점">장단점</h3>
<h4 id="장점">장점</h4>
<ul>
  <li>문자열, 정수 정렬 가능.
    <h4 id="단점">단점</h4>
  </li>
  <li>자릿수가 없는 것은 정렬 불가능(부동 소숫점 등)</li>
  <li>중간 결과를 저장할 bucket 공간 필요.</li>
</ul>

<h3 id="구현-방법">구현 방법</h3>
<ul>
  <li>arrLen = arr.len;</li>
  <li>maxVal = max value of arr;</li>
  <li>for exp = 1 to exp of maxVal
    <ul>
      <li>bucketSort(arr, arrLen, exp);</li>
    </ul>
  </li>
</ul>

<h4 id="bucketsortarr-arrlen-exp">bucketSort(arr, arrLen, exp)</h4>
<ul>
  <li>bucket[arrLen];</li>
  <li>count[10];</li>
  <li>for cnt = 0 to arrLen - 1
    <ul>
      <li>count[(arr[cnt] / exp) % 10]++; //현재 자릿수에 맞춰 정렬</li>
    </ul>
  </li>
  <li>for cnt = 1 to 9
    <ul>
      <li>count[cnt] += count[cnt - 1]; //누적합 계산</li>
    </ul>
  </li>
  <li>for cnt = arrLen - 1 to 0 //counting sort
    <ul>
      <li>bucket[count[(arr[cnt] / exp) % 10] - 1] = arr[cnt];</li>
      <li>count[(arr / exp) % 10]–;</li>
    </ul>
  </li>
  <li>for cnt = 0 to arrLen - 1
    <ul>
      <li>arr[cnt] = bucket[cnt];</li>
    </ul>
  </li>
</ul>

<h3 id="왜-아래부터-측정하는가">왜 아래부터 측정하는가?</h3>
<ul>
  <li>MSD(Most Significant Digit)와 LSD(Least Significant Digit) 비교 문제</li>
  <li>MSD는 가장 큰 자릿수부터 counting sort
    <ul>
      <li>마지막 자릿수까지 확인 필요 X.</li>
      <li>정렬 됐는지 확인하는 과정이 필요해 추가적인 메모리 사용.</li>
      <li>알고리즘이 일관되지 않음 (만일 exp가 다른 값들이 있다면 따로 sorting해줘야 함.)</li>
    </ul>
  </li>
  <li>LSD는 가장 작은 자릿수부터 counting sort
    <ul>
      <li>마지막 자릿수까지 확인해야 함.</li>
      <li>중간에 정렬 결과를 알 수 없음.</li>
      <li>알고리즘이 일관됨.</li>
      <li>LSD의 경우 자릿수가 정해진 경우 좀 더 빠를 수 있음.</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="algorithm" /><category term="sort" /><summary type="html"><![CDATA[Radix Sort Comparison Sort의 문제 해결.]]></summary></entry><entry><title type="html">Counting Sort</title><link href="http://localhost:4000/algorithm/sort/countingsort.html" rel="alternate" type="text/html" title="Counting Sort" /><published>2024-02-21T19:17:00+09:00</published><updated>2024-02-21T19:17:00+09:00</updated><id>http://localhost:4000/algorithm/sort/countingsort</id><content type="html" xml:base="http://localhost:4000/algorithm/sort/countingsort.html"><![CDATA[<h1 id="counting-sort">Counting Sort</h1>
<blockquote>
  <p>n개의 원소 배열을 정렬하는 가짓수는 n!</p>

  <p>해당 방법으로 만든 트리의 말단 노드가 n! 이상이 되기 위해선 2^h &gt;= n!을 만족하는 h를 가지고 h &gt; O(nlogn)을 만족.(h는 트리의 높이)</p>

  <p>O(nlogn)을 줄일 수 있는 방법은 Comparison을 하지 않는 것!</p>
</blockquote>

<ul>
  <li>counting이 필요하다!(각 숫자가 몇 번 등장했는지 센다)</li>
  <li>정렬하는 배열이 특정 범위 내에 있을 때 사용한다.</li>
</ul>

<h4 id="시간복잡도">시간복잡도</h4>
<ul>
  <li>O(n + k) ,k는 배열에서 나오는 최댓값
    <h4 id="공간복잡도">공간복잡도</h4>
  </li>
  <li>O(k) ,k개의 배열을 만들어야 함.</li>
</ul>

<h3 id="장단점">장단점</h3>
<h4 id="장점">장점</h4>
<ul>
  <li>O(n)의 시간 복잡도
    <h4 id="단점">단점</h4>
  </li>
  <li>메모리 낭비가 심함.
    <h3 id="구현-방법">구현 방법</h3>
  </li>
  <li>arrLen = arr.len;</li>
  <li>returnArr[arrLen]; //반환해줄 정렬된 배열</li>
  <li>countLen = max value in arr;</li>
  <li>count[countLen];</li>
  <li>for cnt = 0 to arrLen - 1
    <ul>
      <li>count[arr[cnt]]++; //arr 안에 있는 값이 몇 번 등장했는지 카운트!</li>
    </ul>
  </li>
  <li>for cnt = 1 to arrLen - 1
    <ul>
      <li>count[cnt] += count[cnt - 1]; //count를 누적합으로 만들어줘 index 위치를 특정!</li>
    </ul>
  </li>
  <li>for cnt = arrLen - 1 to 0
    <ul>
      <li>returnArr[count[arr[cnt]] - 1] = arr[cnt];</li>
      <li>count[cnt]–;</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="algorithm" /><category term="sort" /><category term="sort" /><summary type="html"><![CDATA[Counting Sort n개의 원소 배열을 정렬하는 가짓수는 n! 해당 방법으로 만든 트리의 말단 노드가 n! 이상이 되기 위해선 2^h &gt;= n!을 만족하는 h를 가지고 h &gt; O(nlogn)을 만족.(h는 트리의 높이) O(nlogn)을 줄일 수 있는 방법은 Comparison을 하지 않는 것!]]></summary></entry><entry><title type="html">Sieve of Eratosthenes</title><link href="http://localhost:4000/algorithm/math/sieveeratos.html" rel="alternate" type="text/html" title="Sieve of Eratosthenes" /><published>2024-02-21T19:14:00+09:00</published><updated>2024-02-21T19:14:00+09:00</updated><id>http://localhost:4000/algorithm/math/sieveeratos</id><content type="html" xml:base="http://localhost:4000/algorithm/math/sieveeratos.html"><![CDATA[<h1 id="sieve-of-eratosthenes">Sieve of Eratosthenes</h1>
<blockquote>
  <p>에라토크테네스의 체.</p>
</blockquote>

<ul>
  <li>소수를 찾는 방법.</li>
  <li>체로 수를 거르는 것 같다 하여 이런 이름이 붙었다.</li>
</ul>

<h3 id="방법">방법</h3>
<ul>
  <li>1~n까지 숫자 중 소수를 찾는다고 하자.</li>
  <li>숫자를 쭉 쓰고 1을 제거한다.</li>
  <li>2를 제외한 2의 배수 제거</li>
  <li>3을 제외한 3의 배수 제거</li>
  <li>…</li>
  <li>소수인 m(m &lt; sqrt(n))을 제외한 m의 배수 제거</li>
</ul>

<h3 id="구현-방법-c">구현 방법 (c)</h3>
<ul>
  <li>let MAX = 1000001</li>
  <li>prime[MAX] = {0, };</li>
  <li>change_bool(int start, int acc, int flag)
    <ul>
      <li>for cnt = start; cnt &lt; MAX; cnt += acc
        <ul>
          <li>prime[cnt] = flag;</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>prime[2] = 1; // 2는 소수</li>
  <li>prime[3] = 1; // 3은 소수. 나머지 홀수만 판별하자!</li>
  <li>change_bool(5, 6, 1); // 5 mod 6 참으로 설정.</li>
  <li>change_bool(7, 6, 1); // 1 mod 6 참으로 설정. 1은 소수가 아니므로 7부터.</li>
  <li>// 위의 두 집합은 2의 배수도, 3의 배수도 아닌 숫자 집합!</li>
  <li>for prime_cnt = 5; prime_sq = 25; prime_sq &lt; MAX
    <ul>
      <li>nxt = (prime_cnt - 3) % 6 // prime_cnt가 5 mod 6이면 2, 1 mod 6이면 4</li>
      <li>if (prime[prime_cnt] == 1) //현재 숫자가 소수?
        <ul>
          <li>add_cnt = prime_cnt * 6 // prime_cnt mod 6만 검사</li>
          <li>change_bool(prime_sq, add_cnt; 0) // prime_cnt^2 미만 숫자는 소수로 판별 됐음. prime_cnt^2 이상의 숫자만 판별.</li>
          <li>change_bool(nxt * prime_cnt + prime_sq, add_cnt, 0) // prime_cnt(primr_cnt + nxt) 부터</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>prime_cnt += nxt</li>
  <li>prime_sq = prime_cnt * prime_cnt</li>
</ul>]]></content><author><name></name></author><category term="algorithm" /><category term="math" /><category term="math" /><summary type="html"><![CDATA[Sieve of Eratosthenes 에라토크테네스의 체.]]></summary></entry><entry><title type="html">Permutation &amp;amp; Combination</title><link href="http://localhost:4000/algorithm/permuncomb.html" rel="alternate" type="text/html" title="Permutation &amp;amp; Combination" /><published>2024-02-21T19:10:00+09:00</published><updated>2024-02-21T19:10:00+09:00</updated><id>http://localhost:4000/algorithm/permuncomb</id><content type="html" xml:base="http://localhost:4000/algorithm/permuncomb.html"><![CDATA[<h1 id="permutation--combination">Permutation &amp; Combination</h1>

<blockquote>
  <p>순열과 조합. 아래에 나오는 n은 전체 집합 요소의 개수, r은 해당 부분 집합의 길이를 의미한다.</p>
</blockquote>

<h3 id="permutation-순열-npr">Permutation (순열, nPr)</h3>
<ul>
  <li>순서를 정해서 부분 집합을 만드는 방법.</li>
  <li>즉, 같은 요소들로 차있더라도 순서가 다르다면 다른 것으로 인식한다.</li>
  <li>총 부분 집합의 개수는 아래와 같이 계산할 수 있다.
    <blockquote>
      <p>nPr = n * (n - 1) * (n - 2) * … * (n - r + 1)</p>
    </blockquote>
  </li>
</ul>

<h4 id="중복-순열">중복 순열</h4>
<ul>
  <li>요소의 중복을 허용하는 순열.</li>
  <li>총 부분 집합의 개수는 n^r개다.</li>
</ul>

<h3 id="combination-조합-ncr">Combination (조합, nCr)</h3>
<ul>
  <li>순서 없이 부분 집합을 만드는 방법.</li>
  <li>같은 요소들로 차 있다면 같은 것으로 인식한다.</li>
  <li>총 부분 집합의 개수는 아래와 같이 계산할 수 있다.
    <ul>
      <li><sub>n</sub>C<sub>r</sub> = n * (n - 1) * (n - 2) * … * (n - r + 1) / r!</li>
    </ul>
  </li>
  <li>nCr은 두 조합의 합으로 나눌 수 있다.
    <ul>
      <li><sub>n</sub>C<sub>r</sub> = <sub>n-1</sub>C<sub>r</sub> + <sub>n-1</sub>C<sub>r - 1</sub></li>
    </ul>
  </li>
</ul>

<h4 id="중복-조합">중복 조합</h4>
<ul>
  <li>요소의 중복을 허용하는 조합.</li>
  <li>총 부분 집합의 개수는 <sub>n</sub>H<sub>r</sub> = <sub>n+r-1</sub>C<sub>r</sub> = <sub>n+r-1</sub>C<sub>n-1</sub></li>
</ul>]]></content><author><name></name></author><category term="algorithm" /><category term="math" /><summary type="html"><![CDATA[Permutation &amp; Combination]]></summary></entry><entry><title type="html">LRU cache</title><link href="http://localhost:4000/algorithm/lrucache.html" rel="alternate" type="text/html" title="LRU cache" /><published>2024-02-21T18:58:00+09:00</published><updated>2024-02-21T18:58:00+09:00</updated><id>http://localhost:4000/algorithm/lrucache</id><content type="html" xml:base="http://localhost:4000/algorithm/lrucache.html"><![CDATA[<h1 id="lru-cache">LRU cache</h1>
<blockquote>
  <p>Latest Recently Used Cache</p>
</blockquote>

<h3 id="cache">Cache</h3>
<ul>
  <li>데이터나 값을 미리 복사해 놓은 임시 장소.</li>
  <li>접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하는 경우 사용.</li>
  <li>미리 데이터를 복사해 놓으면 계산이나 접근 시간 없이 빠르게 데이터에 접근 가능.</li>
  <li>사용 가능한 리소스 양 제한 있음.</li>
</ul>

<h3 id="lru-cache-1">LRU Cache</h3>
<ul>
  <li>OS의 페이지 교체 알고리즘의 하나.</li>
  <li>가장 오래 사용하지 않은 페이지를 교체하는 알고리즘.</li>
  <li>공간이 부족하면 가장 최근에 사용하지 않은 항목을 제거.</li>
</ul>

<h3 id="구현-방법">구현 방법</h3>
<ul>
  <li>Doubly Linked List로 구현.</li>
  <li>head에 가까운 데이터일수록 최근에 사용한 데이터.</li>
  <li>tail에 가까울수록 사용하지 않은 데이터.</li>
  <li>사용 가능한 리소스를 다 쓴 상태에서 새로운 데이터를 추가할 때 tail의 데이터를 제거한다.</li>
</ul>]]></content><author><name></name></author><category term="algorithm" /><summary type="html"><![CDATA[LRU cache Latest Recently Used Cache]]></summary></entry></feed>